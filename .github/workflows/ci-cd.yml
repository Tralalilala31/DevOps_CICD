on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]
  schedule:
    - cron: "0 22 * * *"

name: CI/CD Pipeline

env:
  PROJECT_NAME: cicd_project

jobs:
  build_frontend:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Builder le frontend via Docker Compose
        run: docker compose build frontend

  build_test_backend:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Lancer l'environnement en fond
        run: docker compose up -d --build

      - name: Run unit and integration tests
        run: |
          docker compose up -d --build
          docker compose exec backend npm run test:unit

      - name: Nettoyage
        if: always()
        run: docker compose down --volumes

  perf_tests:
    needs: build_test_backend
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Start containers for perf tests
        run: docker compose up -d --build

      - name: Run performance tests inside backend
        run: docker compose exec backend node tests/perf/perf-test.js

      - name: Nettoyage
        if: always()
        run: docker compose down --volumes

  e2e_tests:
    # if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v3

      - name: Lancer les tests E2E
        run: |
          docker compose up -d --build
          docker compose exec backend npm run test:e2e

      - name: Nettoyage
        if: always()
        run: docker compose down -v

  deploy_staging:
    needs: [build_frontend, build_test_backend]
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: http://212.83.130.245:81

    steps:
      - uses: actions/checkout@v3

      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: Modifier le .env
        run: |
          sed -i "s/^DATABASE_ROOT_PASSWORD=.*/DATABASE_ROOT_PASSWORD=${{ secrets.PROD_DATABASE_ROOT_PASSWORD }}/" .env
          sed -i "s/^DATABASE_ADMIN_PASSWORD=.*/DATABASE_ADMIN_PASSWORD=${{ secrets.PROD_DATABASE_ADMIN_PASSWORD }}/" .env
          sed -i 's/^PORT_FRONT=.*/PORT_FRONT=82/' .env
          sed -i 's/^PORT_BACK=.*/PORT_BACK=3002/' .env
          sed -i 's/^PORT_PHPMYADMIN=.*/PORT_PHPMYADMIN=8082/' .env
          echo "ðŸ”§ Fichier .env modifiÃ© pour production"

      - name: CrÃ©er le paquet de dÃ©ploiement
        run: |
          tar -czf staging-deployment.tar.gz \
            --exclude='*.tar.gz' \
            .

      - name: TransfÃ©rer les fichiers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' scp -o StrictHostKeyChecking=no \
            staging-deployment.tar.gz \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }}:/home/cicd/

      - name: DÃ©ployer les containers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
            tar -xzf staging-deployment.tar.gz -C /home/cicd/staging
            cd /home/cicd/staging
            
            echo "ðŸš€ DÃ©marrage des services..."
            docker compose up -d --build

            echo "ðŸ“Š Services exposÃ©s :"
            docker compose ps
          EOF

  deploy_production:
    needs: deploy_staging
    # if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    environment:
      name: production
      url: http://212.83.130.245:80

    steps:
      - uses: actions/checkout@v3

      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: Modifier le .env
        run: |
          sed -i "s/^DATABASE_ROOT_PASSWORD=.*/DATABASE_ROOT_PASSWORD=${{ secrets.PROD_DATABASE_ROOT_PASSWORD }}/" .env
          sed -i "s/^DATABASE_ADMIN_PASSWORD=.*/DATABASE_ADMIN_PASSWORD=${{ secrets.PROD_DATABASE_ADMIN_PASSWORD }}/" .env
          sed -i 's/^PORT_FRONT=.*/PORT_FRONT=80/' .env
          sed -i 's/^PORT_BACK=.*/PORT_BACK=3000/' .env
          sed -i 's/^PORT_PHPMYADMIN=.*/PORT_PHPMYADMIN=8080/' .env
          echo "ðŸ”§ Fichier .env modifiÃ© pour production"

      - name: CrÃ©er le paquet de dÃ©ploiement
        run: |
          tar -czf staging-deployment.tar.gz \
            --exclude='*.tar.gz' \
            .

      - name: TransfÃ©rer les fichiers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' scp -o StrictHostKeyChecking=no \
            staging-deployment.tar.gz \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }}:/home/cicd/

      - name: Backup de la production existante
        run: |
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'

            set -e

            BACKUP_DIR="/home/cicd/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_DIR"

            if [ -d "/home/cicd/production" ]; then
              cp -r /home/cicd/production "$BACKUP_DIR/"
              echo "âœ… Dossier copiÃ© : $BACKUP_DIR"
            fi

            # Sauvegarde DB si conteneur existant
            if docker ps --format '{{.Names}}' | grep -q "${PROJECT_NAME}_mysql_prod"; then
              docker exec ${PROJECT_NAME}_mysql_prod \
                mysqldump -u root -p${{ secrets.DATABASE_ROOT_PASSWORD }} ${PROJECT_NAME}_prod > "$BACKUP_DIR/db.sql" || true
              echo "ðŸ’¾ Dump MySQL sauvegardÃ©."
            fi
          EOF

      - name: DÃ©ployer les containers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
            tar -xzf staging-deployment.tar.gz -C /home/cicd/staging
            cd /home/cicd/staging
            
            echo "ðŸš€ DÃ©marrage des services..."
            docker compose up -d --build

            echo "ðŸ“Š Services exposÃ©s :"
            docker compose ps
          EOF

      - name: Notifier le succÃ¨s du dÃ©ploiement
        run: |
          echo "ðŸŽ‰ Production dÃ©ployÃ©e avec succÃ¨s !"
          echo "Version: ${{ github.ref_name }}"
          echo "URL: http://212.83.130.245:4000"

  notify_webhook_success:
    if: success()
    needs: [deploy_staging, deploy_production]
    runs-on: ubuntu-latest
    steps:
      - name: Notify success
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success", 
              "message": "âœ… Build & deploy completed",
              "project": "${{ env.PROJECT_NAME }}",
              "version": "${{ github.ref_name }}",
              "environment": "production"
            }'

  notify_webhook_failure:
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Notify failure
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failure", 
              "message": "âŒ Ã‰chec du pipeline CI/CD",
              "project": "${{ env.PROJECT_NAME }}",
              "branch": "${{ github.ref_name }}"
            }'
