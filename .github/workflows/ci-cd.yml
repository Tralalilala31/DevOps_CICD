on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]
  schedule:
    - cron: "0 22 * * *" # Tous les jours à 22h pour les tests e2e

name: CI/CD Pipeline

env:
  PROJECT_NAME: cicd_project

jobs:
  test_webhook:
    runs-on: ubuntu-latest
    steps:
      - name: Test webhook
        run: |
          curl -v -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{"status":"test","message":"🚀 Webhook de test"}'

  # build:
  #   runs-on: ubuntu-latest

  #   steps:
  #     - uses: actions/checkout@v3

  #     - name: Build and test Docker services
  #       run: |
  #         echo "🚀 Building and starting services..."
  #         docker compose build
  #         docker compose up -d --wait

  #         echo "✅ Services healthy - Test successful!"
  #         docker compose ps

  #     - name: Clean Docker environment
  #       if: always()
  #       run: |
  #         echo "🧹 Cleaning up..."
  #         docker compose down -v --remove-orphans
  #         docker system prune -f
  #         echo "✅ Cleanup completed"

  check_deploy_status:
    runs-on: ubuntu-latest
    outputs:
      deploy_blocked: ${{ steps.check.outputs.deploy_blocked }}
    steps:
      - name: Check if deployment is blocked
        id: check
        run: |
          # Récupère le statut depuis les variables du repository ou utilise false par défaut
          DEPLOY_BLOCKED="${{ vars.DEPLOY_BLOCKED }}"
          if [ -z "$DEPLOY_BLOCKED" ] || [ "$DEPLOY_BLOCKED" != "true" ]; then
            DEPLOY_BLOCKED="false"
          fi
          echo "deploy_blocked=$DEPLOY_BLOCKED" >> $GITHUB_OUTPUT
          echo "🔍 Deploy blocked status: $DEPLOY_BLOCKED"

  backend_tests:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Start development environment
        run: docker compose up -d --build --wait backend

      - name: Run backend unit tests
        run: docker compose exec backend npm run test:unit

  perf_tests:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Building backend service
        run: |
          docker compose \
          -f compose.yml \
          -f compose.testing.yml \
          build backend

      - name: Run performance tests
        run: |
          docker compose \
            -f compose.yml \
            -f compose.testing.yml \
            up --abort-on-container-exit --exit-code-from backend-test

  e2e_tests:
    needs: check_deploy_status
    # S'exécute si c'est un schedule ET que deploy n'est pas bloqué, OU si ce n'est pas un schedule
    if: |
      (github.event_name == 'schedule' && needs.check_deploy_status.outputs.deploy_blocked != 'true') ||
      github.event_name != 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      MYSQL_VERSION: 8.0
      DATABASE_ROOT_PASSWORD: ${{ secrets.DATABASE_ROOT_PASSWORD }}
      DATABASE_ADMIN_PASSWORD: ${{ secrets.DATABASE_ADMIN_PASSWORD }}
      PROJECT_NAME: cicd_project
      PORT_BACK: 3000
      PORT_FRONT: 4200
      PORT_PMA: 8080
    steps:
      - uses: actions/checkout@v3

      - name: Build & start full stack for E2E (sans e2e-tests)
        run: |
          docker compose \
            -f compose.yml \
            -f compose.testing.yml \
            up -d --build --wait mysql backend frontend

      - name: Dump backend logs on failure
        if: failure()
        run: |
          echo "=== BACKEND LOGS ==="
          docker compose -f compose.yml -f compose.testing.yml logs backend

      - name: Run E2E spec (dans un conteneur frais)
        run: |
          docker compose \
            -f compose.yml \
            -f compose.testing.yml \
            run --rm e2e-tests

      - name: Update deploy status on E2E success
        if: success() && github.event_name == 'schedule'
        run: |
          echo "✅ Tests e2e réussis - Déblocage des déploiements"
          curl -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/variables/DEPLOY_BLOCKED \
            -d '{"name":"DEPLOY_BLOCKED","value":"false"}'

      - name: Update deploy status on E2E failure
        if: failure() && github.event_name == 'schedule'
        run: |
          echo "❌ Tests e2e échoués - Blocage des déploiements"
          curl -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/variables/DEPLOY_BLOCKED \
            -d '{"name":"DEPLOY_BLOCKED","value":"true"}' || \
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/variables \
            -d '{"name":"DEPLOY_BLOCKED","value":"true"}'

  e2e_tests_skipped:
    needs: check_deploy_status
    if: github.event_name == 'schedule' && needs.check_deploy_status.outputs.deploy_blocked == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Skip E2E tests - Deploy blocked
        run: |
          echo "⏭️ Tests e2e ignorés car les déploiements sont bloqués (DEPLOY_BLOCKED=true)"
          echo "Pour débloquer, vous devez manuellement définir la variable DEPLOY_BLOCKED à 'false' dans les paramètres du repository"

  check_secrets:
    runs-on: ubuntu-latest
    steps:
      - name: Validate required secrets
        run: |
          echo "🔍 Validating secrets..."
          # Database secrets
          if [ -z "${{ secrets.DATABASE_ROOT_PASSWORD }}" ]; then
            echo "❌ DATABASE_ROOT_PASSWORD is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.DATABASE_ADMIN_PASSWORD }}" ]; then
            echo "❌ DATABASE_ADMIN_PASSWORD is empty!"
            exit 1
          fi
          # SSH secrets
          if [ -z "${{ secrets.RSA }}" ]; then
            echo "❌ RSA is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_USER }}" ]; then
            echo "❌ SSH_USER is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_HOST }}" ]; then
            echo "❌ SSH_HOST is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "❌ WEBHOOK_URL is empty!"
            exit 1
          fi
          echo "✅ All secrets are valid!"

  deploy_staging:
    needs: [
        test_webhook,
        backend_tests,
        check_secrets,
        e2e_tests,
        check_deploy_status,
      ] #, build]
    runs-on: ubuntu-latest
    if: |
      (success() || needs.e2e_tests.result == 'skipped') &&
      needs.check_deploy_status.outputs.deploy_blocked != 'true' &&
      github.event_name != 'schedule'
    environment:
      name: staging
      url: http://212.83.130.245:81

    steps:
      - uses: actions/checkout@v3

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.RSA }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Update environment variables for staging
        run: |
          sed -i "s/^DATABASE_ROOT_PASSWORD=.*/DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}/" .env
          sed -i "s/^DATABASE_ADMIN_PASSWORD=.*/DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}/" .env
          sed -i 's/^PORT_FRONT=.*/PORT_FRONT=81/' .env
          sed -i 's/^PORT_BACK=.*/PORT_BACK=3001/' .env
          sed -i 's/^PORT_PMA=.*/PORT_PMA=8081/' .env
          echo "🔧 Environment file updated for staging"

      - name: Deploy files to staging server
        run: |
          rsync -avz --delete . \
            -e "ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no" \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/cicd/staging/

      - name: Start staging containers
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            set -e
            cd /home/cicd/staging

            echo "🚀 Starting services..."
            docker compose \
            -f compose.yml \
            -f compose.staging.yml \
            up -d --build --wait

            echo "📊 Exposed services :"
            docker compose \
            -f compose.yml \
            -f compose.staging.yml \
            ps
          EOF

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/id_rsa

  deploy_production:
    needs: [
        test_webhook,
        backend_tests,
        check_secrets,
        e2e_tests,
        check_deploy_status,
      ] #, build]
    runs-on: ubuntu-latest
    if: |
      (success() || needs.e2e_tests.result == 'skipped') &&
      needs.check_deploy_status.outputs.deploy_blocked != 'true' &&
      github.event_name != 'schedule'
    environment:
      name: production
      url: http://212.83.130.245:80

    steps:
      - uses: actions/checkout@v3

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.RSA }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Update environment variables for production
        run: |
          sed -i "s/^DATABASE_ROOT_PASSWORD=.*/DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}/" .env
          sed -i "s/^DATABASE_ADMIN_PASSWORD=.*/DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}/" .env
          sed -i 's/^PORT_FRONT=.*/PORT_FRONT=80/' .env
          sed -i 's/^PORT_BACK=.*/PORT_BACK=3000/' .env
          sed -i 's/^PORT_PMA=.*/PORT_PMA=8080/' .env
          echo "🔧 Environment file updated for production"

      - name: Deploy files to production server
        run: |
          rsync -avz --delete . \
            -e "ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no" \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/cicd/production/

      - name: Backup existing production
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            set -e

            BACKUP_DIR="/home/cicd/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_DIR"

            if [ -d "/home/cicd/production" ]; then
              cp -r /home/cicd/production "$BACKUP_DIR/"
              echo "✅ Folder copied: $BACKUP_DIR"
            fi

            # Database backup if container exists
            if docker ps --format '{{.Names}}' | grep -q "${PROJECT_NAME}_mysql_prod"; then
              docker exec ${PROJECT_NAME}_mysql_prod \
                mysqldump -u root -p${{ secrets.DATABASE_ROOT_PASSWORD }} ${PROJECT_NAME}_prod > "$BACKUP_DIR/db.sql" || true
            fi
          EOF

      - name: Start production containers
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            set -e
            cd /home/cicd/production

            echo "🚀 Starting services..."
            docker compose \
            -f compose.yml \
            -f compose.prod.yml \
            up \
            -d \
            --build

            echo "📊 Exposed services :"
            docker compose \
            -f compose.yml \
            -f compose.prod.yml \
            ps
          EOF

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/id_rsa

  notify_webhook_success:
    if: success()
    needs: deploy_production
    runs-on: ubuntu-latest
    steps:
      - name: Notify success
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success", 
              "message": "✅ Build & deploy completed",
              "project": "${{ env.PROJECT_NAME }}",
              "version": "${{ github.ref_name }}",
              "environment": "production"
            }'

  notify_webhook_failure:
    if: failure()
    runs-on: ubuntu-latest
    needs: deploy_production
    steps:
      - name: Notify failure
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failure", 
              "message": "❌ Échec du pipeline CI/CD",
              "project": "${{ env.PROJECT_NAME }}",
              "version": "${{ github.ref_name }}",
              "environment": "production"
            }'
