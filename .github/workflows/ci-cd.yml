on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']
  schedule:
    - cron: '0 22 * * *'

name: CI/CD Pipeline

env:
  PROJECT_NAME: cicd_project

jobs:
  build_frontend:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Builder le frontend via Docker Compose
        run: docker compose build frontend

  build_test_backend:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Lancer l'environnement en fond
        run: docker compose up -d --build

      - name: Run unit and integration tests
        run: docker compose run --rm backend npm run test:unit

      - name: Nettoyage
        run: docker compose down --volumes

  perf_tests:
    needs: build_test_backend
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: G√©n√©rer le fichier .env (performance)
        run: |
          sed -e "s|\${PROJECT_NAME}|${{ env.PROJECT_NAME }}|g" \
              -e "s|\${DATABASE_ADMIN_USER}|${{ secrets.DATABASE_ADMIN_USER }}|g" \
              -e "s|\${DATABASE_ADMIN_PASSWORD}|${{ secrets.DATABASE_ADMIN_PASSWORD }}|g" \
              -e "s|\${DATABASE_ROOT_PASSWORD}|${{ secrets.DATABASE_ROOT_PASSWORD }}|g" \
              -e "s|NODE_ENV=.*|NODE_ENV=performance|g" \
            back-end/.env.template > .env

          echo "=== Contenu du fichier .env g√©n√©r√© (sans secrets) ==="
          grep -v PASSWORD .env | grep -v SECRET

      - name: Start containers for perf tests
        run: docker compose up -d --build

      - name: Run performance tests inside backend
        run: docker compose exec backend node tests/perf/perf-test.js

      - name: Nettoyage
        if: always()
        run: docker compose down --volumes

  e2e_tests:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v3

      - name: G√©n√©rer .env
        run: |
          sed -e "s|\${PROJECT_NAME}|${{ env.PROJECT_NAME }}|g" \
              -e "s|\${DATABASE_ADMIN_USER}|${{ secrets.DATABASE_ADMIN_USER }}|g" \
              -e "s|\${DATABASE_ADMIN_PASSWORD}|${{ secrets.DATABASE_ADMIN_PASSWORD }}|g" \
              -e "s|\${DATABASE_ROOT_PASSWORD}|${{ secrets.DATABASE_ROOT_PASSWORD }}|g" \
              -e "s|NODE_ENV=.*|NODE_ENV=e2e|g" \
            back-end/.env.template > .env
  
          echo "=== .env g√©n√©r√© (sans secrets) ==="
          grep -v PASSWORD .env | grep -v SECRET

      - name: Lancer les E2E via Docker
        run: docker compose -f compose.yml up --build --abort-on-container-exit e2e

      - name: Nettoyage
        if: always()
        run: docker compose -f compose.yml down --volumes

  deploy_staging:
    needs: [build_frontend, build_test_backend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: http://212.83.130.245:3000

    steps:
      - uses: actions/checkout@v3

      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: G√©n√©rer le fichier .env.staging depuis template
        run: |
          sed -e "s|\${PROJECT_NAME}|${{ env.PROJECT_NAME }}|g" \
              -e "s|\${DATABASE_ADMIN_USER}|${{ secrets.DATABASE_ADMIN_USER }}|g" \
              -e "s|\${DATABASE_ADMIN_PASSWORD}|${{ secrets.DATABASE_ADMIN_PASSWORD }}|g" \
              -e "s|\${DATABASE_ROOT_PASSWORD}|${{ secrets.DATABASE_ROOT_PASSWORD }}|g" \
              -e "s|NODE_ENV=.*|NODE_ENV=staging|g" \
              -e "s|DB_NAME=.*|DB_NAME=${{ env.PROJECT_NAME }}_staging|g" \
              -e "s|APP_URL=.*|APP_URL=http://212.83.130.245:3000|g" \
              -e "s|API_URL=.*|API_URL=http://212.83.130.245:3001|g" \
              -e "s|PORT=.*|PORT=3001|g" \
              -e "s|FRONTEND_PORT=.*|FRONTEND_PORT=3000|g" \
            back-end/.env.template > .env.staging

      - name: Cr√©er le paquet de d√©ploiement
        run: |
          mkdir -p deploy/staging
          cp -r front-end back-end .env.staging compose.yml deploy/staging/
          tar -czf staging-deployment.tar.gz -C deploy/staging .

      - name: D√©ployer sur le serveur staging
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
          
            set -e
            mkdir -p /home/cicd/staging
            cd /home/cicd
  
            if ! command -v docker &> /dev/null; then
              echo "‚ùå Docker n'est pas install√©"
              exit 1
            fi
  
            if ! docker compose version &> /dev/null; then
              echo "üß© Installation de docker compose v2..."
              mkdir -p ~/.docker/cli-plugins
              curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) \
                -o ~/.docker/cli-plugins/docker-compose
              chmod +x ~/.docker/cli-plugins/docker-compose
            fi
  
            rm -rf staging/*
          EOF

      - name: Transf√©rer les fichiers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' scp -o StrictHostKeyChecking=no \
            staging-deployment.tar.gz \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }}:/home/cicd/

      - name: D√©ployer les containers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
            cd /home/cicd
            tar -xzf staging-deployment.tar.gz -C staging/
            cd staging
          
            docker compose down --volumes || true
            cp .env.staging .env
            docker compose -f compose.yml -f compose.prod.yml up -d --build
          
            echo "‚åõ Attente du d√©marrage des services..."
            docker compose ps
          EOF

      - name: V√©rification du d√©ploiement
        run: |
          echo "üîç V√©rification du staging"
          sleep 30
          curl -f http://212.83.130.245:3001/health || echo "‚ö†Ô∏è API indisponible"
          curl -f http://212.83.130.245:3000 || echo "‚ö†Ô∏è Frontend indisponible"
          echo "‚úÖ Staging op√©rationnel"

  deploy_production:
    needs: deploy_staging
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    environment:
      name: production
      url: http://212.83.130.245:4000

    steps:
      - uses: actions/checkout@v3

      - name: Installer sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: G√©n√©rer `.env.production` depuis `.env.template`
        run: |
          sed -e "s|\${PROJECT_NAME}|${{ env.PROJECT_NAME }}|g" \
              -e "s|\${DATABASE_ADMIN_USER}|${{ secrets.DATABASE_ADMIN_USER }}|g" \
              -e "s|\${DATABASE_ADMIN_PASSWORD}|${{ secrets.DATABASE_ADMIN_PASSWORD }}|g" \
              -e "s|\${DATABASE_ROOT_PASSWORD}|${{ secrets.DATABASE_ROOT_PASSWORD }}|g" \
              -e "s|NODE_ENV=.*|NODE_ENV=production|g" \
              -e "s|DB_NAME=.*|DB_NAME=${{ env.PROJECT_NAME }}_prod|g" \
              -e "s|APP_URL=.*|APP_URL=http://212.83.130.245:4000|g" \
              -e "s|API_URL=.*|API_URL=http://212.83.130.245:4001|g" \
              -e "s|PORT=.*|PORT=4001|g" \
              -e "s|FRONTEND_PORT=.*|FRONTEND_PORT=4000|g" \
            back-end/.env.template > .env.production

      - name: Cr√©er le paquet de d√©ploiement
        run: |
          mkdir -p deploy/production
          cp -r front-end back-end compose.yml .env.production deploy/production/
          tar -czf production-deployment.tar.gz -C deploy/production .

      - name: Backup de la production existante
        run: |
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'
          
            set -e
          
            BACKUP_DIR="/home/cicd/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_DIR"
          
            if [ -d "/home/cicd/production" ]; then
              cp -r /home/cicd/production "$BACKUP_DIR/"
              echo "‚úÖ Dossier copi√© : $BACKUP_DIR"
            fi
          
            # Sauvegarde DB si conteneur existant
            if docker ps --format '{{.Names}}' | grep -q cicd_project_mysql_prod; then
              docker exec cicd_project_mysql_prod \
                mysqldump -u root -p$DATABASE_ROOT_PASSWORD cicd_project_prod > "$BACKUP_DIR/db.sql" || true
              echo "üíæ Dump MySQL sauvegard√©."
            fi
          EOF

      - name: Pr√©parer le serveur distant
        run: |
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'
          
            mkdir -p /home/cicd/production
          
            # Installer docker compose v2 si n√©cessaire
            if ! docker compose version &> /dev/null; then
              mkdir -p ~/.docker/cli-plugins
              curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) \
                -o ~/.docker/cli-plugins/docker-compose
              chmod +x ~/.docker/cli-plugins/docker-compose
            fi
          
            rm -rf /home/cicd/production/*
          EOF

      - name: Envoyer le paquet de d√©ploiement
        run: |
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' scp -o StrictHostKeyChecking=no \
            production-deployment.tar.gz \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }}:/home/cicd/

      - name: D√©ployer la nouvelle version
        run: |
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'
          
            set -e
          
            cd /home/cicd
            tar -xzf production-deployment.tar.gz -C production/
            cd production
          
            cp .env.production .env
            docker compose down --volumes || true
            docker compose -f compose.yml -f compose.prod.yml up -d --build
          
            echo "‚è≥ Attente du d√©marrage..."
            docker compose ps
          EOF

      - name: V√©rifications sant√© de la prod
        run: |
          echo "üè• V√©rifications de sant√© production"
          
          echo "Test API..."
          curl -f http://212.83.130.245:4001/health || {
            echo "‚ùå API non disponible"
            exit 1
          }
          
          echo "Test Frontend..."
          curl -f http://212.83.130.245:4000 || {
            echo "‚ùå Frontend non disponible"
            exit 1
          }
          
          echo "Test temps de r√©ponse..."
          response_time=$(curl -o /dev/null -s -w "%{time_total}" http://212.83.130.245:4001/health)
          echo "‚è± Temps r√©ponse API : ${response_time}s"
          
          if (( $(echo "$response_time > 2.0" | bc -l) )); then
            echo "‚ö†Ô∏è Temps de r√©ponse √©lev√©"
          fi
          
          echo "‚úÖ D√©ploiement production OK"

      - name: Notifier le succ√®s du d√©ploiement
        run: |
          echo "üéâ Production d√©ploy√©e avec succ√®s !"
          echo "Version: ${{ github.ref_name }}"
          echo "URL: http://212.83.130.245:4000"

  notify_webhook_success:
    if: success()
    needs: [ deploy_staging, deploy_production ]
    runs-on: ubuntu-latest
    steps:
      - name: Notify success
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success", 
              "message": "‚úÖ Build & deploy completed",
              "project": "${{ env.PROJECT_NAME }}",
              "version": "${{ github.ref_name }}",
              "environment": "production"
            }'

  notify_webhook_failure:
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Notify failure
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failure", 
              "message": "‚ùå √âchec du pipeline CI/CD",
              "project": "${{ env.PROJECT_NAME }}",
              "branch": "${{ github.ref_name }}"
            }'