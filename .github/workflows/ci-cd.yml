on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]
  schedule:
    - cron: "0 22 * * *"

name: CI/CD Pipeline

env:
  PROJECT_NAME: cicd_project

jobs:
  #test_webhook:
  #  runs-on: ubuntu-latest
  #  steps:
  #    - name: Test webhook
  #      run: |
  #        curl -v -X POST ${{ secrets.WEBHOOK_URL }} \
  #          -H "Content-Type: application/json" \
  #          -d '{"status":"test","message":"üöÄ Webhook de test"}'

  # build:
  #   runs-on: ubuntu-latest

  #   steps:
  #     - uses: actions/checkout@v3

  #     - name: Build and test Docker services
  #       run: |
  #         echo "üöÄ Building and starting services..."
  #         docker compose build
  #         docker compose up -d --wait

  #         echo "‚úÖ Services healthy - Test successful!"
  #         docker compose ps

  #     - name: Clean Docker environment
  #       if: always()
  #       run: |
  #         echo "üßπ Cleaning up..."
  #         docker compose down -v --remove-orphans
  #         docker system prune -f
  #         echo "‚úÖ Cleanup completed"

  backend_tests:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Start development environment
        run: docker compose up -d --build

      - name: Run backend unit tests
        run: docker compose exec backend npm run test:unit

  perf_tests:
    needs: backend_tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Run performance tests
        run: |
          docker compose \
          -f compose.yml \
          -f compose.testing.yml \
          up --build --abort-on-container-exit backend-test

  e2e_tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v3

      - name: Start containers for E2E tests
        run: |
          docker compose \
          -f compose.yml \
          -f compose.testing.yml \
          up --build -d --wait mysql backend frontend e2e-tests

          docker compose --profile testing

      - name: Run E2E tests
        run: |
          docker compose \
          -f compose.yml \
          -f compose.testing.yml \
          exec e2e-tests node tests/home.spec.js

  check_secrets:
    runs-on: ubuntu-latest
    steps:
      - name: Validate required secrets
        run: |
          echo "üîç Validating secrets..."
          # Database secrets
          if [ -z "${{ secrets.DATABASE_ROOT_PASSWORD }}" ]; then
            echo "‚ùå DATABASE_ROOT_PASSWORD is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.DATABASE_ADMIN_PASSWORD }}" ]; then
            echo "‚ùå DATABASE_ADMIN_PASSWORD is empty!"
            exit 1
          fi
          # SSH secrets
          if [ -z "${{ secrets.STAGING_SSH_PASSWORD }}" ]; then
            echo "‚ùå STAGING_SSH_PASSWORD is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.STAGING_SSH_USER }}" ]; then
            echo "‚ùå STAGING_SSH_USER is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.STAGING_SSH_HOST }}" ]; then
            echo "‚ùå STAGING_SSH_HOST is empty!"
            exit 1
          fi
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "‚ùå WEBHOOK_URL is empty!"
            exit 1
          fi
          echo "‚úÖ All secrets are valid!"

  deploy_staging:
    needs: [backend_tests, check_secrets] #, build]
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: http://212.83.130.245:81

    steps:
      - uses: actions/checkout@v3

      - name: Install SSH tools
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Update environment variables for staging
        run: |
          sed -i "s/^DATABASE_ROOT_PASSWORD=.*/DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}/" .env
          sed -i "s/^DATABASE_ADMIN_PASSWORD=.*/DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}/" .env
          sed -i 's/^PORT_FRONT=.*/PORT_FRONT=81/' .env
          sed -i 's/^PORT_BACK=.*/PORT_BACK=3001/' .env
          sed -i 's/^PORT_PMA=.*/PORT_PMA=8081/' .env
          echo "üîß Environment file updated for staging"

      - name: Deploy files to staging server
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' rsync -avz --delete . \
            -e "ssh -o StrictHostKeyChecking=no" \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }}:/home/cicd/staging/

      - name: Start staging containers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
            set -e
            cd /home/cicd/staging

            echo "üöÄ Starting services..."
            docker compose \
            -f compose.yml \
            -f compose.staging.yml \
            up -d --build --wait

            echo "üìä Exposed services :"
            docker compose \
            -f compose.yml \
            -f compose.staging.yml \
            ps
          EOF

  deploy_production:
    needs: deploy_staging
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment:
      name: production
      url: http://212.83.130.245:80

    steps:
      - uses: actions/checkout@v3
  
      - name: Install SSH tools
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Update environment variables for production
        run: |
          sed -i "s/^DATABASE_ROOT_PASSWORD=.*/DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}/" .env
          sed -i "s/^DATABASE_ADMIN_PASSWORD=.*/DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}/" .env
          sed -i 's/^PORT_FRONT=.*/PORT_FRONT=80/' .env
          sed -i 's/^PORT_BACK=.*/PORT_BACK=3000/' .env
          sed -i 's/^PORT_PMA=.*/PORT_PMA=8080/' .env
          echo "üîß Environment file updated for production"

      - name: Deploy files to production server
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' rsync -avz --delete . \
            -e "ssh -o StrictHostKeyChecking=no" \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }}:/home/cicd/production/

      - name: Backup existing production
        run: |
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'
            set -e

            BACKUP_DIR="/home/cicd/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_DIR"

            if [ -d "/home/cicd/production" ]; then
              cp -r /home/cicd/production "$BACKUP_DIR/"
              echo "‚úÖ Folder copied: $BACKUP_DIR"
            fi

            # Database backup if container exists
            if docker ps --format '{{.Names}}' | grep -q "${PROJECT_NAME}_mysql_prod"; then
              docker exec ${PROJECT_NAME}_mysql_prod \
                mysqldump -u root -p${{ secrets.DATABASE_ROOT_PASSWORD }} ${PROJECT_NAME}_prod > "$BACKUP_DIR/db.sql" || true
            fi
          EOF

      - name: Start production containers
        run: |
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
            set -e
            cd /home/cicd/production

            echo "üöÄ Starting services..."
            docker compose \
            -f compose.yml \
            -f compose.prod.yml \
            up \
            -d \
            --build

            echo "üìä Exposed services :"
            docker compose \
            -f compose.yml \
            -f compose.prod.yml \
            ps
          EOF

  notify_webhook_success:
    if: success()
    needs: [deploy_staging, deploy_production]
    runs-on: ubuntu-latest
    steps:
      - name: Notify success
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success", 
              "message": "‚úÖ Build & deploy completed",
              "project": "${{ env.PROJECT_NAME }}",
              "version": "${{ github.ref_name }}",
              "environment": "production"
            }'

  notify_webhook_failure:
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Notify failure
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failure", 
              "message": "‚ùå √âchec du pipeline CI/CD",
              "project": "${{ env.PROJECT_NAME }}",
              "branch": "${{ github.ref_name }}"
            }'
