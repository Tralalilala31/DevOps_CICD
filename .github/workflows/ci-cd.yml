on:
  push:
    branches: ['*']
  pull_request:
    branches: ['*']
  schedule:
    - cron: '0 22 * * *'

name: CI/CD Pipeline

env:
  PROJECT_NAME: cicd_project

jobs:
  build_frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup environment variables for frontend
        run: |
          cat > front-end/.env << EOF
          VITE_API_URL=${{ secrets.FRONTEND_API_URL }}
          VITE_APP_NAME=${{ env.PROJECT_NAME }}
          VITE_APP_VERSION=${{ github.ref_name }}
          VITE_ENVIRONMENT=ci
          EOF

      - name: Install dependencies & build frontend
        run: |
          cd front-end
          npm ci
          npm run build

  build_test_backend:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0.32
        env:
          MYSQL_DATABASE: ${{ env.PROJECT_NAME }}
          MYSQL_USER: ${{ secrets.DATABASE_ADMIN_USER }}
          MYSQL_PASSWORD: ${{ secrets.DATABASE_ADMIN_PASSWORD }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.DATABASE_ROOT_PASSWORD }}
        ports: ['3306:3306']
        options: >-
          --health-cmd="mysqladmin ping -h localhost"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Générer le fichier .env pour le backend
        run: |
          cd back-end
          echo "PROJECT_NAME=${{ env.PROJECT_NAME }}" > .env
          echo "DATABASE_ADMIN_USER=${{ secrets.DATABASE_ADMIN_USER }}" >> .env
          echo "DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}" >> .env
          echo "DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}" >> .env
          echo "DB_HOST=127.0.0.1" >> .env
          echo "DB_PORT=3306" >> .env
          echo "DB_USER=${{ secrets.DATABASE_ADMIN_USER }}" >> .env
          echo "DB_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}" >> .env
          echo "DB_NAME=${{ env.PROJECT_NAME }}" >> .env
          echo "NODE_ENV=test" >> .env
          echo "FRONTEND_URL=http://localhost:4200" >> .env
          
          echo "=== Contenu du fichier .env généré (sans secrets) ==="
          cat .env | grep -v PASSWORD | grep -v SECRET

      - name: Install backend dependencies
        run: |
          cd back-end
          npm ci

      - name: Run unit and integration tests
        run: |
          cd back-end
          npm run test:unit
          npm run test:integration

  perf_tests:
    needs: build_test_backend
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0.32
        env:
          MYSQL_DATABASE: ${{ env.PROJECT_NAME }}
          MYSQL_USER: ${{ secrets.DATABASE_ADMIN_USER }}
          MYSQL_PASSWORD: ${{ secrets.DATABASE_ADMIN_PASSWORD }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.DATABASE_ROOT_PASSWORD }}
        ports: ['3306:3306']
        options: >-
          --health-cmd="mysqladmin ping -h localhost"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    steps:
      - uses: actions/checkout@v3

      - name: Generate complete .env for performance tests
        run: |
          cd back-end
          cat > .env << EOF
          PROJECT_NAME=${{ env.PROJECT_NAME }}
          
          DATABASE_ADMIN_USER=${{ secrets.DATABASE_ADMIN_USER }}
          DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}
          DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}
          DB_HOST=127.0.0.1
          DB_PORT=3306
          DB_USER=${{ secrets.DATABASE_ADMIN_USER }}
          DB_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}
          DB_NAME=${{ env.PROJECT_NAME }}
          
          NODE_ENV=performance
          
          PERF_TEST_DURATION=60
          PERF_TEST_CONCURRENT_USERS=100
          EOF

      - name: Install and run performance tests
        run: |
          cd back-end/tests/perf
          npm ci
          node perf-test.js

  e2e_tests:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v3

      - name: Configure docker-compose environment
        run: |
          sudo apt-get update && sudo apt-get install -y gettext-base
          
          export PROJECT_NAME=${{ env.PROJECT_NAME }}
          export DATABASE_ADMIN_USER=${{ secrets.DATABASE_ADMIN_USER }}
          export DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}
          export DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}
          
          envsubst < docker-compose.template.yml > docker-compose.yml

      - name: Setup E2E environment
        run: |
          docker-compose up -d
          sleep 10

      - name: Run E2E tests
        run: |
          cd e2e-tests
          npm ci
          npm run test:e2e

  deploy_staging:
    needs: [build_frontend, build_test_backend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: http://212.83.130.245:3000

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install sshpass for SSH authentication
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass rsync

      - name: Configure staging environment
        run: |
          echo > .env.staging << EOF
          PROJECT_NAME=${{ env.PROJECT_NAME }}
          NODE_ENV=staging
          DATABASE_ADMIN_USER=${{ secrets.DATABASE_ADMIN_USER }}
          DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}
          DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}
          DB_HOST=localhost
          DB_PORT=3306
          DB_NAME=${{ env.PROJECT_NAME }}_staging
          APP_URL=http://212.83.130.245:3000
          API_URL=http://212.83.130.245:3001
          PORT=3001
          FRONTEND_PORT=3000
          EOF

      - name: Build application for staging
        run: |
          cd front-end
          npm ci
          npm run build
          cd ..
          
          cd back-end
          npm ci
          cd ..

      - name: Create deployment package
        run: |
          mkdir -p deploy/staging
          
          cp -r front-end/dist deploy/staging/frontend
          cp -r back-end deploy/staging/
          cp .env.staging deploy/staging/.env
          cp compose.staging.yml deploy/staging/compose.yml
          
          tar -czf staging-deployment.tar.gz -C deploy/staging .

      - name: Deploy to staging server
        run: |
          echo "🟢 Déploiement vers staging sur ${{ secrets.STAGING_SSH_HOST }}"
          
          sshpass -p '${{ secrets.STAGING_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
            set -e
          
            # Préparation dossier
            mkdir -p /home/cicd/staging
          
            # Installer docker-compose si manquant
            if ! command -v docker-compose &> /dev/null; then
              echo "🧩 Installation de docker-compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
          
            # Extraction et déploiement
            cd /home/cicd
            tar -xzf staging-deployment.tar.gz -C staging/
            cd staging
          
            docker-compose down || true
            docker-compose up --build -d
            sleep 10
            docker-compose ps
          EOF
    
          - name: Verify staging deployment
            run: |
              echo "🔍 Vérification du déploiement staging"
              sleep 30
              
              curl -f http://212.83.130.245:3001/health || echo "⚠️ API health check failed"
              
              curl -f http://212.83.130.245:3000 || echo "⚠️ Frontend check failed"
              
              echo "✅ Déploiement staging terminé"

  deploy_production:
    needs: deploy_staging
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    environment:
      name: production
      url: http://212.83.130.245:4000

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install sshpass for SSH authentication
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass rsync

      - name: Configure production environment securely
        run: |
          umask 077
          
          echo > .env.production << EOF
          PROJECT_NAME=${{ env.PROJECT_NAME }}
          NODE_ENV=production
          
          DATABASE_ADMIN_USER=${{ secrets.DATABASE_ADMIN_USER }}
          DATABASE_ADMIN_PASSWORD=${{ secrets.DATABASE_ADMIN_PASSWORD }}
          DATABASE_ROOT_PASSWORD=${{ secrets.DATABASE_ROOT_PASSWORD }}
          DB_HOST=localhost
          DB_PORT=3306
          DB_NAME=${{ env.PROJECT_NAME }}_prod
          
          APP_URL=http://212.83.130.245:4000
          API_URL=http://212.83.130.245:4001
          PORT=4001
          FRONTEND_PORT=4000
          
          APP_VERSION=${{ github.ref_name }}
          BUILD_NUMBER=${{ github.run_number }}
          COMMIT_SHA=${{ github.sha }}
          
          LOG_LEVEL=info
          MAX_REQUEST_SIZE=10mb
          RATE_LIMIT_WINDOW=900000
          RATE_LIMIT_MAX=100
          EOF

      - name: Build application for production
        run: |
          cd front-end
          npm ci
          NODE_ENV=production npm run build
          cd ..
          
          cd back-end
          npm ci --production
          cd ..

      - name: Create production deployment package
        run: |
          mkdir -p deploy/production
          
          cp -r front-end/dist deploy/production/frontend
          cp -r back-end deploy/production/
          cp .env.production deploy/production/.env
          cp docker-compose.production.yml deploy/production/docker-compose.yml
          
          mkdir -p deploy/production/scripts
          cp scripts/backup-db.sh deploy/production/scripts/
          cp scripts/health-check.sh deploy/production/scripts/
          
          tar -czf production-deployment.tar.gz -C deploy/production .

      - name: Backup current production (if exists)
        run: |
          echo "💾 Sauvegarde de la production actuelle"
          
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'
            # Créer le dossier de backup avec timestamp
            BACKUP_DIR="/home/cicd/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p $BACKUP_DIR
          
            if [ -d "/home/cicd/production" ]; then
              cp -r /home/cicd/production $BACKUP_DIR/
              echo "✅ Backup créé dans $BACKUP_DIR"
            fi
          
            if command -v docker &> /dev/null; then
              docker exec cicd_project_mysql_prod mysqldump -u root -p$DATABASE_ROOT_PASSWORD cicd_project_prod > $BACKUP_DIR/database.sql || true
            fi
          EOF

      - name: Deploy to production server
        run: |
          echo "🚀 Déploiement vers production sur ${{ secrets.PROD_SSH_HOST }}"
          
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} \
            'mkdir -p /home/cicd/production'
          
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' rsync -avz --delete \
            -e "ssh -o StrictHostKeyChecking=no" \
            production-deployment.tar.gz ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }}:/home/cicd/
          
          sshpass -p '${{ secrets.PROD_SSH_PASSWORD }}' ssh -o StrictHostKeyChecking=no \
            ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'
            cd /home/cicd
          
            tar -xzf production-deployment.tar.gz -C production/
            cd production
          
            echo "🔄 Mise à jour en cours..."
          
            docker-compose build
          
            docker-compose up -d --force-recreate --remove-orphans
          
            echo "⏳ Attente du démarrage des services..."
            sleep 30
          
            docker-compose ps
            echo "✅ Déploiement terminé"
          EOF

      - name: Run production health checks
        run: |
          echo "🏥 Vérifications de santé production"
          sleep 60 
          
          echo "Test API health endpoint..."
          curl -f http://212.83.130.245:4001/health || {
            echo "❌ API health check failed"
            exit 1
          }
          
          echo "Test frontend availability..."
          curl -f http://212.83.130.245:4000 || {
            echo "❌ Frontend check failed"
            exit 1
          }
          
          echo "Test de performance basique..."
          response_time=$(curl -o /dev/null -s -w "%{time_total}" http://212.83.130.245:4001/health)
          echo "Temps de réponse API: ${response_time}s"
          
          if (( $(echo "$response_time > 2.0" | bc -l) )); then
            echo "⚠️ API response time is high: ${response_time}s"
          fi
          
          echo "✅ Déploiement production vérifié et fonctionnel"

      - name: Notify production deployment success
        run: |
          echo "🎉 Production deployée avec succès!"
          echo "Version: ${{ github.ref_name }}"
          echo "URL: http://212.83.130.245:4000"

  notify_webhook_success:
    if: success()
    needs: [ deploy_staging, deploy_production ]
    runs-on: ubuntu-latest
    steps:
      - name: Notify success
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success", 
              "message": "✅ Build & deploy completed",
              "project": "${{ env.PROJECT_NAME }}",
              "version": "${{ github.ref_name }}",
              "environment": "production"
            }'

  notify_webhook_failure:
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Notify failure
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failure", 
              "message": "❌ Échec du pipeline CI/CD",
              "project": "${{ env.PROJECT_NAME }}",
              "branch": "${{ github.ref_name }}"
            }'